<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title></title>
          <meta name="description" content="" />
          <meta name="keywords" content="" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      
      <link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../index.js"></script>
      <script type="text/javascript" src="../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title"><span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="../../../index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.org" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="org"></a><a id="org:org"></a>
      <span class="permalink">
      <a href="../../../org/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">org</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="org.graphframes" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="graphframes"></a><a id="graphframes:graphframes"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">graphframes</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="org">org</a></dd></dl></div>
    </li><li name="org.graphframes.examples" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="examples"></a><a id="examples:examples"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/examples/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../examples/index.html"><span class="name">examples</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.graphframes">graphframes</a></dd></dl></div>
    </li><li name="org.graphframes.lib" visbl="pub" class="indented3 current" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lib"></a><a id="lib:lib"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">lib</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="org.graphframes">graphframes</a></dd></dl></div>
    </li><li class="current-entities indented3">
                        <a class="object" href="AggregateMessages$.html" title=""></a>
                        <a class="class" href="AggregateMessages.html" title="This is a primitive for implementing graph algorithms."></a>
                        <a href="AggregateMessages.html" title="This is a primitive for implementing graph algorithms.">AggregateMessages</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="BFS.html" title="Breadth-first search (BFS)"></a>
                        <a href="BFS.html" title="Breadth-first search (BFS)">BFS</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="ConnectedComponents$.html" title=""></a>
                        <a class="class" href="ConnectedComponents.html" title="Connected Components algorithm."></a>
                        <a href="ConnectedComponents.html" title="Connected Components algorithm.">ConnectedComponents</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="LabelPropagation.html" title="Run static Label Propagation for detecting communities in networks."></a>
                        <a href="LabelPropagation.html" title="Run static Label Propagation for detecting communities in networks.">LabelPropagation</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="PageRank.html" title="PageRank algorithm implementation."></a>
                        <a href="PageRank.html" title="PageRank algorithm implementation.">PageRank</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="ParallelPersonalizedPageRank.html" title="Parallel Personalized PageRank algorithm implementation."></a>
                        <a href="ParallelPersonalizedPageRank.html" title="Parallel Personalized PageRank algorithm implementation.">ParallelPersonalizedPageRank</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="Pregel$.html" title="Constants and utilities for the Pregel algorithm."></a>
                        <a class="class" href="Pregel.html" title="Implements a Pregel-like bulk-synchronous message-passing API based on DataFrame operations."></a>
                        <a href="Pregel.html" title="Implements a Pregel-like bulk-synchronous message-passing API based on DataFrame operations.">Pregel</a>
                      </li><li class="current-entities indented3">
                        <a class="object" href="SVDPlusPlus$.html" title=""></a>
                        <a class="class" href="SVDPlusPlus.html" title="Implement SVD++ based on &quot;Factorization Meets the Neighborhood: a Multifaceted Collaborative Filtering Model&quot;, available at https://dl.acm.org/citation.cfm?id=1401944."></a>
                        <a href="SVDPlusPlus.html" title="Implement SVD++ based on &quot;Factorization Meets the Neighborhood: a Multifaceted Collaborative Filtering Model&quot;, available at https://dl.acm.org/citation.cfm?id=1401944.">SVDPlusPlus</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="ShortestPaths.html" title="Computes shortest paths from every vertex to the given set of landmark vertices."></a>
                        <a href="ShortestPaths.html" title="Computes shortest paths from every vertex to the given set of landmark vertices.">ShortestPaths</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="StronglyConnectedComponents.html" title="Compute the strongly connected component (SCC) of each vertex and return a DataFrame with each vertex assigned to the SCC containing that vertex."></a>
                        <a href="StronglyConnectedComponents.html" title="Compute the strongly connected component (SCC) of each vertex and return a DataFrame with each vertex assigned to the SCC containing that vertex.">StronglyConnectedComponents</a>
                      </li><li class="current-entities indented3">
                        <span class="separator"></span>
                        <a class="class" href="TriangleCount.html" title="Computes the number of triangles passing through each vertex."></a>
                        <a href="TriangleCount.html" title="Computes the number of triangles passing through each vertex.">TriangleCount</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="package value">
      <div id="definition">
        <div class="big-circle package">p</div>
        <p id="owner"><a href="../../index.html" class="extype" name="org">org</a>.<a href="../index.html" class="extype" name="org.graphframes">graphframes</a></p>
        <h1>lib<span class="permalink">
      <a href="../../../org/graphframes/lib/index.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">lib</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              
            </ol>
          </div>
          
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="org.graphframes.lib.AggregateMessages" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="AggregateMessagesextendsArgumentswithSerializable"></a><a id="AggregateMessages:AggregateMessages"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/AggregateMessages.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="This is a primitive for implementing graph algorithms." href="AggregateMessages.html"><span class="name">AggregateMessages</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <a href="https://www.scala-lang.org/api/2.12.18/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      <p class="shortcomment cmt">This is a primitive for implementing graph algorithms.</p><div class="fullcomment"><div class="comment cmt"><p>This is a primitive for implementing graph algorithms. This method aggregates messages from the
neighboring edges and vertices of each vertex.</p><p>For each triplet (source vertex, edge, destination vertex) in <a href="../GraphFrame.html#triplets:org.apache.spark.sql.DataFrame" class="extmbr" name="org.graphframes.GraphFrame#triplets">GraphFrame.triplets</a>, this can
send a message to the source and/or destination vertices.</p><ul><li><code>AggregateMessages.sendToSrc()</code> sends a message to the source vertex of each triplet</li><li><code>AggregateMessages.sendToDst()</code> sends a message to the destination vertex of each triplet</li><li><code>AggregateMessages.agg</code> specifies an aggregation function for aggregating the messages sent
    to each vertex. It also runs the aggregation, computing a DataFrame with one row for each
    vertex which receives &gt; 0 messages. The DataFrame has 2 columns:<ul><li>vertex column ID (named <a href="../GraphFrame$.html#ID:String" class="extmbr" name="org.graphframes.GraphFrame#ID">GraphFrame.ID</a>)</li><li>aggregate from messages sent to vertex (with the name given to the <code>Column</code> specified in
      <code>AggregateMessages.agg()</code>)</li></ul></li></ul><p>When specifying the messages and aggregation function, the user may reference columns using:</p><ul><li><a href="AggregateMessages$.html#src:org.apache.spark.sql.Column" class="extmbr" name="org.graphframes.lib.AggregateMessages#src">AggregateMessages.src</a>: column for source vertex of edge</li><li><a href="AggregateMessages$.html#edge:org.apache.spark.sql.Column" class="extmbr" name="org.graphframes.lib.AggregateMessages#edge">AggregateMessages.edge</a>: column for edge</li><li><a href="AggregateMessages$.html#dst:org.apache.spark.sql.Column" class="extmbr" name="org.graphframes.lib.AggregateMessages#dst">AggregateMessages.dst</a>: column for destination vertex of edge</li><li><a href="AggregateMessages$.html#msg:org.apache.spark.sql.Column" class="extmbr" name="org.graphframes.lib.AggregateMessages#msg">AggregateMessages.msg</a>: message sent to vertex (for aggregation function)</li></ul><p>Note: If you use this operation to write an iterative algorithm, you may want to use
<a href="AggregateMessages$.html#getCachedDataFrame(df:org.apache.spark.sql.DataFrame):org.apache.spark.sql.DataFrame" class="extmbr" name="org.graphframes.lib.AggregateMessages#getCachedDataFrame">getCachedDataFrame()</a> as a workaround for caching
issues.
</p></div><dl class="attributes block"> <div class="block">Example:
               <ol><li class="cmt"><p>
  We can use this function to compute the in-degree of each vertex</p><pre><span class="kw">val</span> g: GraphFrame = Graph.textFile(<span class="lit">"twittergraph"</span>)
<span class="kw">val</span> inDeg: DataFrame =
  g.aggregateMessages().sendToDst(lit(<span class="num">1</span>)).agg(sum(AggregateMessagesBuilder.msg))</pre></li></ol>
            </div></dl></div>
    </li><li name="org.graphframes.lib.BFS" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="BFSextendsArgumentswithSerializable"></a><a id="BFS:BFS"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/BFS.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Breadth-first search (BFS)" href="BFS.html"><span class="name">BFS</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <a href="https://www.scala-lang.org/api/2.12.18/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      <p class="shortcomment cmt">Breadth-first search (BFS)</p><div class="fullcomment"><div class="comment cmt"><p>Breadth-first search (BFS)</p><p>This method returns a DataFrame of valid shortest paths from vertices matching <code>fromExpr</code> to
vertices matching <code>toExpr</code>. If multiple paths are valid and have the same length, the DataFrame
will return one Row for each path. If no paths are valid, the DataFrame will be empty. Note:
&quot;Shortest&quot; means globally shortest path. I.e., if the shortest path between two vertices
matching <code>fromExpr</code> and <code>toExpr</code> is length 5 (edges) but no path is shorter than 5, then all
paths returned by BFS will have length 5.</p><p>The returned DataFrame will have the following columns:</p><ul><li><code>from</code> start vertex of path</li><li><code>e[i]</code> edge i in the path, indexed from 0</li><li><code>v[i]</code> intermediate vertex i in the path, indexed from 1</li><li><code>to</code> end vertex of path
Each of these columns is a StructType whose fields are the same as the columns of
<a href="../GraphFrame.html#vertices:org.apache.spark.sql.DataFrame" class="extmbr" name="org.graphframes.GraphFrame#vertices">GraphFrame.vertices</a> or <a href="../GraphFrame.html#edges:org.apache.spark.sql.DataFrame" class="extmbr" name="org.graphframes.GraphFrame#edges">GraphFrame.edges</a>.</li></ul><p>For example, suppose we have a graph g. Say the vertices DataFrame of g has columns &quot;id&quot; and
&quot;job&quot;, and the edges DataFrame of g has columns &quot;src&quot;, &quot;dst&quot;, and &quot;relation&quot;.</p><pre><span class="cmt">// Search from vertex "Joe" to find the closet vertices with attribute job = CEO.</span>
g.bfs(col(<span class="lit">"id"</span>) === <span class="lit">"Joe"</span>, col(<span class="lit">"job"</span>) === <span class="lit">"CEO"</span>).run()</pre><p>If we found a path of 3 edges, each row would have columns:</p><pre>from | e0 | v1 | e1 | v2 | e2 | to</pre><p> In the above row, each vertex column (from, v1, v2,
to) would have fields &quot;id&quot; and &quot;job&quot; (just like g.vertices). Each edge column (e0, e1, e2)
would have fields &quot;src&quot;, &quot;dst&quot;, and &quot;relation&quot;.</p><p>If there are ties, then each of the equal paths will be returned as a separate Row.</p><p>If one or more vertices match both the from and to conditions, then there is a 0-hop path. The
returned DataFrame will have the &quot;from&quot; and &quot;to&quot; columns (as above); however, the &quot;from&quot; and
&quot;to&quot; columns will be exactly the same. There will be one row for each vertex in
<a href="../GraphFrame.html#vertices:org.apache.spark.sql.DataFrame" class="extmbr" name="org.graphframes.GraphFrame#vertices">GraphFrame.vertices</a> matching both <code>fromExpr</code> and <code>toExpr</code>.</p><p>Parameters:</p><ul><li><code>fromExpr</code> Spark SQL expression specifying valid starting vertices for the BFS. This
    condition will be matched against each vertex's id or attributes. To start from a specific
    vertex, this could be &quot;id = [start vertex id]&quot;. To start from multiple valid vertices, this
    can operate on vertex attributes.</li><li><code>toExpr</code> Spark SQL expression specifying valid target vertices for the BFS. This condition
    will be matched against each vertex's id or attributes.</li><li><code>maxPathLength</code> Limit on the length of paths. If no valid paths of length &lt;= maxPathLength
    are found, then the BFS is terminated. (default = 10)</li><li><code>edgeFilter</code> Spark SQL expression specifying edges which may be used in the search. This
    allows the user to disallow crossing certain edges. Such filters can be applied post-hoc
    after BFS, run specifying the filter here is more efficient.</li></ul><p>Returns:</p><ul><li>DataFrame of valid shortest paths found in the BFS</li></ul><p>from | e0 | v1 | e1 | v2 | e2 | to
}}}
to) would have fields &quot;id&quot; and &quot;job&quot; (just like g.vertices). Each edge column (e0, e1, e2)
would have fields &quot;src&quot;, &quot;dst&quot;, and &quot;relation&quot;.</p><p>If there are ties, then each of the equal paths will be returned as a separate Row.</p><p>If one or more vertices match both the from and to conditions, then there is a 0-hop path. The
returned DataFrame will have the &quot;from&quot; and &quot;to&quot; columns (as above); however, the &quot;from&quot; and
&quot;to&quot; columns will be exactly the same. There will be one row for each vertex in
<a href="../GraphFrame.html#vertices:org.apache.spark.sql.DataFrame" class="extmbr" name="org.graphframes.GraphFrame#vertices">GraphFrame.vertices</a> matching both <code>fromExpr</code> and <code>toExpr</code>.</p><p>Parameters:</p><ul><li><code>fromExpr</code> Spark SQL expression specifying valid starting vertices for the BFS. This
    condition will be matched against each vertex's id or attributes. To start from a specific
    vertex, this could be &quot;id = [start vertex id]&quot;. To start from multiple valid vertices, this
    can operate on vertex attributes.</li><li><code>toExpr</code> Spark SQL expression specifying valid target vertices for the BFS. This condition
    will be matched against each vertex's id or attributes.</li><li><code>maxPathLength</code> Limit on the length of paths. If no valid paths of length &lt;= maxPathLength
    are found, then the BFS is terminated. (default = 10)</li><li><code>edgeFilter</code> Spark SQL expression specifying edges which may be used in the search. This
    allows the user to disallow crossing certain edges. Such filters can be applied post-hoc
    after BFS, run specifying the filter here is more efficient.</li></ul><p>Returns:</p><ul><li>DataFrame of valid shortest paths found in the BFS
</li></ul></div></div>
    </li><li name="org.graphframes.lib.ConnectedComponents" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ConnectedComponentsextendsArgumentswithLoggingwithWithAlgorithmChoicewithWithCheckpointIntervalwithWithBroadcastThresholdwithWithIntermediateStorageLevelwithWithUseLabelsAsComponentswithWithMaxIter"></a><a id="ConnectedComponents:ConnectedComponents"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/ConnectedComponents.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Connected Components algorithm." href="ConnectedComponents.html"><span class="name">ConnectedComponents</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <span class="extype" name="org.graphframes.Logging">Logging</span> with <span class="extype" name="org.graphframes.WithAlgorithmChoice">WithAlgorithmChoice</span> with <span class="extype" name="org.graphframes.WithCheckpointInterval">WithCheckpointInterval</span> with <span class="extype" name="org.graphframes.WithBroadcastThreshold">WithBroadcastThreshold</span> with <span class="extype" name="org.graphframes.WithIntermediateStorageLevel">WithIntermediateStorageLevel</span> with <span class="extype" name="org.graphframes.WithUseLabelsAsComponents">WithUseLabelsAsComponents</span> with <span class="extype" name="org.graphframes.WithMaxIter">WithMaxIter</span></span>
      </span>
      
      <p class="shortcomment cmt">Connected Components algorithm.</p><div class="fullcomment"><div class="comment cmt"><p>Connected Components algorithm.</p><p>Computes the connected component membership of each vertex and returns a DataFrame of vertex
information with each vertex assigned a component ID.</p><p>The resulting DataFrame contains all the vertex information and one additional column:</p><ul><li>component (<code>LongType</code>): unique ID for this component
</li></ul></div></div>
    </li><li name="org.graphframes.lib.LabelPropagation" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="LabelPropagationextendsArgumentswithWithAlgorithmChoicewithWithCheckpointIntervalwithWithMaxIter"></a><a id="LabelPropagation:LabelPropagation"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/LabelPropagation.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Run static Label Propagation for detecting communities in networks." href="LabelPropagation.html"><span class="name">LabelPropagation</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <span class="extype" name="org.graphframes.WithAlgorithmChoice">WithAlgorithmChoice</span> with <span class="extype" name="org.graphframes.WithCheckpointInterval">WithCheckpointInterval</span> with <span class="extype" name="org.graphframes.WithMaxIter">WithMaxIter</span></span>
      </span>
      
      <p class="shortcomment cmt">Run static Label Propagation for detecting communities in networks.</p><div class="fullcomment"><div class="comment cmt"><p>Run static Label Propagation for detecting communities in networks.</p><p>Each node in the network is initially assigned to its own community. At every iteration, nodes
send their community affiliation to all neighbors and update their state to the mode community
affiliation of incoming messages.</p><p>LPA is a standard community detection algorithm for graphs. It is very inexpensive
computationally, although (1) convergence is not guaranteed and (2) one can end up with trivial
solutions (all nodes are identified into a single community).</p><p>The resulting DataFrame contains all the original vertex information and one additional column:</p><ul><li>label (<code>LongType</code>): label of community affiliation
</li></ul></div></div>
    </li><li name="org.graphframes.lib.PageRank" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PageRankextendsArguments"></a><a id="PageRank:PageRank"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/PageRank.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="PageRank algorithm implementation." href="PageRank.html"><span class="name">PageRank</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span></span>
      </span>
      
      <p class="shortcomment cmt">PageRank algorithm implementation.</p><div class="fullcomment"><div class="comment cmt"><p>PageRank algorithm implementation. There are two implementations of PageRank.</p><p>The first one uses the <code>org.apache.spark.graphx.graph</code> interface with <code>aggregateMessages</code> and
runs PageRank for a fixed number of iterations. This can be executed by setting <code>maxIter</code>.
Conceptually, the algorithm does the following:</p><pre><span class="kw">var</span> PR = <span class="std">Array</span>.fill(n)( <span class="num">1.0</span> )
<span class="kw">val</span> oldPR = <span class="std">Array</span>.fill(n)( <span class="num">1.0</span> )
<span class="kw">for</span>( iter <span class="kw">&lt;-</span> <span class="num">0</span> until maxIter ) {
  swap(oldPR, PR)
  <span class="kw">for</span>( i <span class="kw">&lt;-</span> <span class="num">0</span> until n ) {
    PR[i] = alpha + (<span class="num">1</span> - alpha) * inNbrs[i].map(j <span class="kw">=&gt;</span> oldPR[j] / outDeg[j]).sum
  }
}</pre><p>The second implementation uses the <code>org.apache.spark.graphx.Pregel</code> interface and runs PageRank
until convergence and this can be run by setting <code>tol</code>. Conceptually, the algorithm does the
following:</p><pre><span class="kw">var</span> PR = <span class="std">Array</span>.fill(n)( <span class="num">1.0</span> )
<span class="kw">val</span> oldPR = <span class="std">Array</span>.fill(n)( <span class="num">0.0</span> )
<span class="kw">while</span>( max(abs(PR - oldPr)) &gt; tol ) {
  swap(oldPR, PR)
  <span class="kw">for</span>( i <span class="kw">&lt;-</span> <span class="num">0</span> until n <span class="kw">if</span> abs(PR[i] - oldPR[i]) &gt; tol ) {
    PR[i] = alpha + (<span class="num">1</span> - \alpha) * inNbrs[i].map(j <span class="kw">=&gt;</span> oldPR[j] / outDeg[j]).sum
  }
}</pre><p><code>alpha</code> is the random reset probability (typically 0.15), <code>inNbrs[i]</code> is the set of neighbors
which link to <code>i</code> and <code>outDeg[j]</code> is the out degree of vertex <code>j</code>.</p><p>Note that this is not the &quot;normalized&quot; PageRank and as a consequence pages that have no inlinks
will have a PageRank of alpha. In particular, the pageranks may have some values greater than 1.</p><p>The resulting vertices DataFrame contains one additional column:</p><ul><li>pagerank (<code>DoubleType</code>): the pagerank of this vertex</li></ul><p>The resulting edges DataFrame contains one additional column:</p><ul><li>weight (<code>DoubleType</code>): the normalized weight of this edge after running PageRank
</li></ul></div></div>
    </li><li name="org.graphframes.lib.ParallelPersonalizedPageRank" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ParallelPersonalizedPageRankextendsArgumentswithWithMaxIter"></a><a id="ParallelPersonalizedPageRank:ParallelPersonalizedPageRank"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/ParallelPersonalizedPageRank.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Parallel Personalized PageRank algorithm implementation." href="ParallelPersonalizedPageRank.html"><span class="name">ParallelPersonalizedPageRank</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <span class="extype" name="org.graphframes.WithMaxIter">WithMaxIter</span></span>
      </span>
      
      <p class="shortcomment cmt">Parallel Personalized PageRank algorithm implementation.</p><div class="fullcomment"><div class="comment cmt"><p>Parallel Personalized PageRank algorithm implementation.</p><p>This implementation uses the standalone <a href="../GraphFrame.html" class="extype" name="org.graphframes.GraphFrame">GraphFrame</a> interface and runs personalized PageRank
in parallel for a fixed number of iterations. This can be run by setting <code>maxIter</code>. The source
vertex Ids are set in <code>sourceIds</code>. A simple local implementation of this algorithm is as
follows.</p><pre><span class="kw">var</span> oldPR = <span class="std">Array</span>.fill(n)( <span class="num">1.0</span> )
<span class="kw">val</span> PR = (<span class="num">0</span> until n).map(i <span class="kw">=&gt;</span> <span class="kw">if</span> sourceIds.contains(i) alpha <span class="kw">else</span> <span class="num">0.0</span>)
<span class="kw">for</span>( iter <span class="kw">&lt;-</span> <span class="num">0</span> until maxIter ) {
  swap(oldPR, PR)
  <span class="kw">for</span>( i <span class="kw">&lt;-</span> <span class="num">0</span> until n ) {
    PR[i] = (<span class="num">1</span> - alpha) * inNbrs[i].map(j <span class="kw">=&gt;</span> oldPR[j] / outDeg[j]).sum
    <span class="kw">if</span> (sourceIds.contains(i)) PR[i] += alpha
  }
}</pre><p><code>alpha</code> is the random reset probability (typically 0.15), <code>inNbrs[i]</code> is the set of neighbors
which link to <code>i</code> and <code>outDeg[j]</code> is the out degree of vertex <code>j</code>.</p><p>Note that this is not the &quot;normalized&quot; PageRank and as a consequence pages that have no inlinks
will have a PageRank of alpha. In particular, the pageranks may have some values greater than 1.</p><p>The resulting vertices DataFrame contains one additional column:</p><ul><li>pageranks (<code>VectorType</code>): the pageranks of this vertex from all input source vertices</li></ul><p>The resulting edges DataFrame contains one additional column:</p><ul><li>weight (<code>DoubleType</code>): the normalized weight of this edge after running PageRank
</li></ul></div></div>
    </li><li name="org.graphframes.lib.Pregel" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="PregelextendsLogging"></a><a id="Pregel:Pregel"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/Pregel.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Implements a Pregel-like bulk-synchronous message-passing API based on DataFrame operations." href="Pregel.html"><span class="name">Pregel</span></a><span class="result"> extends <span class="extype" name="org.graphframes.Logging">Logging</span></span>
      </span>
      
      <p class="shortcomment cmt">Implements a Pregel-like bulk-synchronous message-passing API based on DataFrame operations.</p><div class="fullcomment"><div class="comment cmt"><p>Implements a Pregel-like bulk-synchronous message-passing API based on DataFrame operations.</p><p>See <a href="https://doi.org/10.1145/1807167.1807184">Malewicz et al., Pregel: a system for
large-scale graph processing</a> for a detailed description of the Pregel algorithm.</p><p>You can construct a Pregel instance using either this constructor or
<a href="../GraphFrame.html#pregel:org.graphframes.lib.Pregel" class="extmbr" name="org.graphframes.GraphFrame#pregel">org.graphframes.GraphFrame#pregel</a>, then use builder pattern to describe the operations, and
then call <a href="Pregel.html#run():org.apache.spark.sql.DataFrame" class="extmbr" name="org.graphframes.lib.Pregel#run">run</a> to start a run. It returns a DataFrame of vertices from the last iteration.</p><p>When a run starts, it expands the vertices DataFrame using column expressions defined by
<a href="Pregel.html#withVertexColumn(colName:String,initialExpr:org.apache.spark.sql.Column,updateAfterAggMsgsExpr:org.apache.spark.sql.Column):Pregel.this.type" class="extmbr" name="org.graphframes.lib.Pregel#withVertexColumn">withVertexColumn</a>. Those additional vertex properties can be changed during Pregel
iterations. In each Pregel iteration, there are three phases:</p><ul><li>Given each edge triplet, generate messages and specify target vertices to send, described
    by <a href="Pregel.html#sendMsgToDst(msgExpr:org.apache.spark.sql.Column):Pregel.this.type" class="extmbr" name="org.graphframes.lib.Pregel#sendMsgToDst">sendMsgToDst</a> and <a href="Pregel.html#sendMsgToSrc(msgExpr:org.apache.spark.sql.Column):Pregel.this.type" class="extmbr" name="org.graphframes.lib.Pregel#sendMsgToSrc">sendMsgToSrc</a>.</li><li>Aggregate messages by target vertex IDs, described by <a href="Pregel.html#aggMsgs(aggExpr:org.apache.spark.sql.Column):Pregel.this.type" class="extmbr" name="org.graphframes.lib.Pregel#aggMsgs">aggMsgs</a>.</li><li>Update additional vertex properties based on aggregated messages and states from previous
    iteration, described by <a href="Pregel.html#withVertexColumn(colName:String,initialExpr:org.apache.spark.sql.Column,updateAfterAggMsgsExpr:org.apache.spark.sql.Column):Pregel.this.type" class="extmbr" name="org.graphframes.lib.Pregel#withVertexColumn">withVertexColumn</a>.</li></ul><p>Please find what columns you can reference at each phase in the method API docs.</p><p>You can control the number of iterations by <a href="Pregel.html#setMaxIter(value:Int):Pregel.this.type" class="extmbr" name="org.graphframes.lib.Pregel#setMaxIter">setMaxIter</a> and check API docs for advanced
controls.</p><p>Example code for Page Rank:</p><pre><span class="kw">val</span> edges = ...
<span class="kw">val</span> vertices = GraphFrame.fromEdges(edges).outDegrees.cache()
<span class="kw">val</span> numVertices = vertices.count()
<span class="kw">val</span> graph = GraphFrame(vertices, edges)
<span class="kw">val</span> alpha = <span class="num">0.15</span>
<span class="kw">val</span> ranks = graph.pregel
  .withVertexColumn(<span class="lit">"rank"</span>, lit(<span class="num">1.0</span> / numVertices),
    coalesce(Pregel.msg, lit(<span class="num">0.0</span>)) * (<span class="num">1.0</span> - alpha) + alpha / numVertices)
  .sendMsgToDst(Pregel.src(<span class="lit">"rank"</span>) / Pregel.src(<span class="lit">"outDegree"</span>))
  .aggMsgs(sum(Pregel.msg))
  .run()</pre></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>
  <a href="../GraphFrame.html#pregel:org.graphframes.lib.Pregel" class="extmbr" name="org.graphframes.GraphFrame#pregel">org.graphframes.GraphFrame#pregel</a></p></span><span class="cmt"><p>
  <a href="https://doi.org/10.1145/1807167.1807184"> Malewicz et al., Pregel: a system for
  large-scale graph processing. </a></p></span></dd></dl></div>
    </li><li name="org.graphframes.lib.SVDPlusPlus" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SVDPlusPlusextendsArgumentswithWithMaxIter"></a><a id="SVDPlusPlus:SVDPlusPlus"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/SVDPlusPlus.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Implement SVD++ based on &quot;Factorization Meets the Neighborhood: a Multifaceted Collaborative Filtering Model&quot;, available at https://dl.acm.org/citation.cfm?id=1401944." href="SVDPlusPlus.html"><span class="name">SVDPlusPlus</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <span class="extype" name="org.graphframes.WithMaxIter">WithMaxIter</span></span>
      </span>
      
      <p class="shortcomment cmt">Implement SVD++ based on &quot;Factorization Meets the Neighborhood: a Multifaceted Collaborative
Filtering Model&quot;, available at <a href="https://dl.acm.org/citation.cfm?id=1401944" target="_blank">https://dl.acm.org/citation.cfm?id=1401944</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Implement SVD++ based on &quot;Factorization Meets the Neighborhood: a Multifaceted Collaborative
Filtering Model&quot;, available at <a href="https://dl.acm.org/citation.cfm?id=1401944" target="_blank">https://dl.acm.org/citation.cfm?id=1401944</a>.</p><p>Note: The status of this algorithm is EXPERIMENTAL. Its API and implementation may be changed
in the future.</p><p>The prediction rule is r<sub>ui</sub> = u + b<sub>u</sub> + b<sub>i</sub> + q<sub>i</sub>*(p<sub>u</sub> + |N(u)|<sup><sup>-0.5</sup></sup>*sum(y)).
See the details on page 6 of the article.</p><p>Configuration parameters: see the description of each parameter in the article.</p><p>Returns a DataFrame with vertex attributes containing the trained model. See the object
(static) members for the names of the output columns.
</p></div></div>
    </li><li name="org.graphframes.lib.ShortestPaths" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ShortestPathsextendsArgumentswithWithAlgorithmChoicewithWithCheckpointInterval"></a><a id="ShortestPaths:ShortestPaths"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/ShortestPaths.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Computes shortest paths from every vertex to the given set of landmark vertices." href="ShortestPaths.html"><span class="name">ShortestPaths</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <span class="extype" name="org.graphframes.WithAlgorithmChoice">WithAlgorithmChoice</span> with <span class="extype" name="org.graphframes.WithCheckpointInterval">WithCheckpointInterval</span></span>
      </span>
      
      <p class="shortcomment cmt">Computes shortest paths from every vertex to the given set of landmark vertices.</p><div class="fullcomment"><div class="comment cmt"><p>Computes shortest paths from every vertex to the given set of landmark vertices. Note that this
takes edge direction into account.</p><p>The returned DataFrame contains all the original vertex information as well as one additional
column:</p><ul><li>distances (<code>MapType[vertex ID type, IntegerType]</code>): For each vertex v, a map containing the
    shortest-path distance to each reachable landmark vertex.
</li></ul></div></div>
    </li><li name="org.graphframes.lib.StronglyConnectedComponents" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StronglyConnectedComponentsextendsArgumentswithWithMaxIter"></a><a id="StronglyConnectedComponents:StronglyConnectedComponents"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/StronglyConnectedComponents.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Compute the strongly connected component (SCC) of each vertex and return a DataFrame with each vertex assigned to the SCC containing that vertex." href="StronglyConnectedComponents.html"><span class="name">StronglyConnectedComponents</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span> with <span class="extype" name="org.graphframes.WithMaxIter">WithMaxIter</span></span>
      </span>
      
      <p class="shortcomment cmt">Compute the strongly connected component (SCC) of each vertex and return a DataFrame with each
vertex assigned to the SCC containing that vertex.</p><div class="fullcomment"><div class="comment cmt"><p>Compute the strongly connected component (SCC) of each vertex and return a DataFrame with each
vertex assigned to the SCC containing that vertex.</p><p>The resulting DataFrame contains all the original vertex information and one additional column:</p><ul><li>component (<code>LongType</code>): unique ID for this component
</li></ul></div></div>
    </li><li name="org.graphframes.lib.TriangleCount" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TriangleCountextendsArguments"></a><a id="TriangleCount:TriangleCount"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/TriangleCount.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a title="Computes the number of triangles passing through each vertex." href="TriangleCount.html"><span class="name">TriangleCount</span></a><span class="result"> extends <span class="extype" name="org.graphframes.lib.Arguments">Arguments</span></span>
      </span>
      
      <p class="shortcomment cmt">Computes the number of triangles passing through each vertex.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the number of triangles passing through each vertex.</p><p>This algorithm ignores edge direction; i.e., all edges are treated as undirected. In a
multigraph, duplicate edges will be counted only once.</p><p>Note that this provides the same algorithm as GraphX, but GraphX assumes the user provides a
graph in the correct format. In Spark 2.0+, GraphX can automatically canonicalize the graph to
put it in this format.</p><p>The returned DataFrame contains all the original vertex information and one additional column:</p><ul><li>count (<code>LongType</code>): the count of triangles
</li></ul></div></div>
    </li></ol>
            </div>

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="org.graphframes.lib.AggregateMessages" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="AggregateMessages"></a><a id="AggregateMessages:AggregateMessages"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/AggregateMessages$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="AggregateMessages$.html"><span class="name">AggregateMessages</span></a><span class="result"> extends <span class="extype" name="org.graphframes.Logging">Logging</span> with <a href="https://www.scala-lang.org/api/2.12.18/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      
    </li><li name="org.graphframes.lib.ConnectedComponents" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ConnectedComponents"></a><a id="ConnectedComponents:ConnectedComponents"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/ConnectedComponents$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="ConnectedComponents$.html"><span class="name">ConnectedComponents</span></a><span class="result"> extends <span class="extype" name="org.graphframes.Logging">Logging</span></span>
      </span>
      
      
    </li><li name="org.graphframes.lib.Pregel" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="Pregel"></a><a id="Pregel:Pregel"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/Pregel$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="Constants and utilities for the Pregel algorithm." href="Pregel$.html"><span class="name">Pregel</span></a><span class="result"> extends <a href="https://www.scala-lang.org/api/2.12.18/scala/Serializable.html#scala.Serializable" class="extype" name="scala.Serializable">Serializable</a></span>
      </span>
      
      <p class="shortcomment cmt">Constants and utilities for the Pregel algorithm.</p>
    </li><li name="org.graphframes.lib.SVDPlusPlus" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SVDPlusPlus"></a><a id="SVDPlusPlus:SVDPlusPlus"></a>
      <span class="permalink">
      <a href="../../../org/graphframes/lib/SVDPlusPlus$.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a title="" href="SVDPlusPlus$.html"><span class="name">SVDPlusPlus</span></a>
      </span>
      
      
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
